# Switch-TC-CPP

The application tests threaded code generated by the editor of hierarchical state machines. The original scheme can be seen in the attached movie. It's another model of a switch affected by two events: __TURN__ and __RESET__. The first switches two states __ON__ and __OFF__, the second resets the state machine to the __OFF__ state regardless of what state it was in before.

## Precondition

The editor's __Planner__ module was supplemented with _C++__ code generator, which automatically generates the __Switch_resetHelper.h__ and __Switch_resetHelper.cpp__ files with the class of the same name. A core has also been added to the application, which services the launch of threaded code and the impact of events on it. This is a set of several very simple classes: __EventWrapper__, which describes and keep an event, __QHsmHelper__ with the __IQHsmStateMachineHelper__ interface, which contains a container of threaded codes and ensures its execution under the influence of events, __ThreadedCodeExecutor__ - a class that ensures the launch of threaded code for a specific state and event.

## Code modification

The generated __Switch_resetHelper.h__ and __Switch_resetHelper.cpp__ files are a skeleton for the logical part of the application, namely the list and bodies of empty transfer functions that can and should be filled with some content. For example, with trace elements in the simplest case. Some functions may not be used and should be deleted or commented out:

```cpp
#ifndef Switch_resetHelper_H
#define Switch_resetHelper_H

#include <string>
#include <functional>
#include <vector>
#include "QHsmHelper.h"

using namespace std;

class Switch_resetHelper {
public:
    Switch_resetHelper();
    // void switchEntry(void* data = nullptr);
    // void switchInit(void* data = nullptr);
    void offEntry(void* data = nullptr);
    void offReset(void* data = nullptr);
    // void offExit(void* data = nullptr);
    void offTurn(void* data = nullptr);
    void onEntry(void* data = nullptr);
    // void onExit(void* data = nullptr);
    void onTurn(void* data = nullptr);
    void init();
    void run(const string& eventName);

private:
    QHsmHelper helper_;
    void createHelper();
};

#endif // Switch_resetHelper_H

```

```cpp
#include <iostream>
#include "Switch_resetHelper.h"
#include "ThreadedCodeExecutor.h"

using namespace std;

Switch_resetHelper::Switch_resetHelper() : helper_("switch") {
    createHelper();
}

// void switchEntry(void* data = nullptr) {
// }

// void switchInit(void* data = nullptr) {
// }

void Switch_resetHelper::offEntry(void* data) {
    cout << "OFF" << endl;
}

void Switch_resetHelper::offReset(void* data) {
    cout << "@RESET" << endl;
}

// void offExit(void* data = nullptr) {
// }

void Switch_resetHelper::offTurn(void* data) {
    cout << "OFF: TURN" << endl;
}

void Switch_resetHelper::onEntry(void* data) {
    cout << "ON " << endl;
}

// void onExit(void* data = nullptr) {
// }

void Switch_resetHelper::onTurn(void* data) {
    cout << "ON : TURN" << endl;
}

void Switch_resetHelper::init() {
    helper_.post("init");
}

void Switch_resetHelper::run(const string& eventName) {
    helper_.post(eventName);
}

void Switch_resetHelper::createHelper() {
    helper_.insert("switch", "init", make_shared<ThreadedCodeExecutor>(&helper_, "off", vector<function<void(void*)>>{
        // [this](void* data) { switchEntry(data); },
        // [this](void* data) { switchInit(data); },
        [this](void* data) { offEntry(data); }
    }));
    helper_.insert("off", "RESET", make_shared<ThreadedCodeExecutor>(&helper_, "off", vector<function<void(void*)>>{
        [this](void* data) { offReset(data); },
        // [this](void* data) { offExit(data); },
        // [this](void* data) { switchInit(data); },
        [this](void* data) { offEntry(data); }
    }));
    helper_.insert("off", "TURN", make_shared<ThreadedCodeExecutor>(&helper_, "on", vector<function<void(void*)>>{
        [this](void* data) { offTurn(data); },
        [this](void* data) { onEntry(data); }
    }));
    helper_.insert("on", "RESET", make_shared<ThreadedCodeExecutor>(&helper_, "off", vector<function<void(void*)>>{
        [this](void* data) { offReset(data); },
        // [this](void* data) { onExit(data); },
        // [this](void* data) { switchInit(data); },
        [this](void* data) { offEntry(data); }
    }));
    helper_.insert("on", "TURN", make_shared<ThreadedCodeExecutor>(&helper_, "off", vector<function<void(void*)>>{
        [this](void* data) { onTurn(data); },
        // [this](void* data) { onExit(data); },
        // [this](void* data) { offExit(data); },
        // [this](void* data) { switchInit(data); },
        [this](void* data) { offEntry(data); }
    }));
}
```

## Description of the application

The application is created as a __ubuntu console application__ and can be launched in terminal mode:

```c
#include "Switch_resetHelper.h"

void testSwitch() {
    Switch_resetHelper hsmHelper;
    hsmHelper.init();
    hsmHelper.run("TURN");
    hsmHelper.run("RESET");
    hsmHelper.run("TURN");
    hsmHelper.run("TURN");
    hsmHelper.run("RESET");
}

int main() {
    testSwitch();
    return 0;
}

```

## Compilation and build

```
micrcx@micrcx-desktop:~/vs_cpp/tc$ make
g++ -Ilogger -c main.cpp -o main.o
g++ -Ilogger -c EventWrapper.cpp -o EventWrapper.o
g++ -Ilogger -c QHsmHelper.cpp -o QHsmHelper.o
g++ -Ilogger -c Runner.cpp -o Runner.o
g++ -Ilogger -c ThreadedCodeExecutor.cpp -o ThreadedCodeExecutor.o
g++ -Ilogger -c Switch_resetHelper.cpp -o Switch_resetHelper.o
g++ main.o EventWrapper.o QHsmHelper.o Runner.o ThreadedCodeExecutor.o Switch_resetHelper.o -o switch
micrcx@micrcx-desktop:~/vs_cpp/tc$
```

## Run

```
micrcx@micrcx-desktop:~/vs_cpp/tc$ ./switch
OFF
OFF: TURN
ON 
@RESET
OFF
OFF: TURN
ON 
ON : TURN
OFF
@RESET
OFF
micrcx@micrcx-desktop:~/vs_cpp/tc$ 
```

## Movie

[cpp_sample.webm](https://github.com/user-attachments/assets/e13eb497-090f-4214-bc86-3cc6936f36c6)

